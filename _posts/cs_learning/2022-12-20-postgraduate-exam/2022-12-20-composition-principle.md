---
layout: post
title: "计算机组成原理"
subtitle: "Composition Principle"
date: 2022-12-20
author: "Kenshin"
header-img: "img/post-bg/post-bg-default.png"
tags:
  - LearnCS
---

- CPU 通过总线类型来识别信息是地址还是数据，通过控制单元 CU(指令执行的不同周期)识别是指令还是数据

- 在虚拟存储器中，当程序正在执行时，由操作系统完成地址映射

  - Cache-主存地址映射由硬件自动完成

- TLB 和 Cache 缺失处理都可以由硬件实现

- 自陷处理完成后返回到陷阱指令的下一条指令执行

- Cache 失配原因可分成以下三类： （3C 模型）

  1、被迫（compulsory）失配：（ 冷启动失配）： 第一次访问存储块时，由于该块不在 cache 中，所以必须首先将引块从主存取入 cache.

  绝对次数与程序有关，随着容量增加成比例增加。可以适当增大块的大小

  2、容量（Capacity）失配：因 cache 不能容纳所有存储块，当程序再次访问到曾装入 cache 又已被替换出去的某块时，出现容量失配。

  与关联度无关，容量增大，容量失配率减少。

  3、冲突（conflict）失配：在采用组关联和直接映象方式的 cache 中，主存的很多块都将对应 cache 的同一块。因这一原因，当程序再次访问到曾装入 cache 又已被替换出去的某块时，出现冲突失配。

  容量一定时，关联度越高，冲突失配越小。

-

# 计算机系统概述

- 发展历程
  - 硬件
    - 电子管（1946 - 1957）机器语言，延迟线或磁鼓存储器
    - 晶体管（1958 - 1964）汇编语言，磁芯存储器
    - 中小规模集成电路（1965 - 1971）操作系统，半导体存储器
    - 超大规模集成电路（1972 - ）微处理器
    - 智能计算机（神经网络计算机），生物计算机与量子计算机
  - 分类
    - 数字计算机
      - 专用计算机
      - 通用计算机：按规模、速度和功能：巨型机、大型机、中型机、小型机、微型机、单片机
    - 模拟计算机
  - 按指令和数据流分类
    - 单指令流单数据流 SISD：传统冯诺依曼体系结构：控制器，存储器，运算器，输入、输出设备
    - 单指令流多数据流 SIMD：阵列处理器、向量处理器
    - 多指令流单数据流 MISD：实际不存在
    - 多指令流多数据流 MIMD：多处理器和多计算机系统
  - 摩尔定律(18 个月晶体管翻一倍)、半导体存储器、微处理器
  - 微处理器是相对于大型机的处理器而言的，微机处理器，与微程序还是硬布线无关
- 软件：高级语言的发展真正促进了软件的发展（面向机器到面向问题），操作系统
  - 面向机器：机器语言，汇编语言。机器语言是唯一机器可以识别与执行的语言
  - 面向问题：FORTRAN科学计算和工程计算, PASCAL结构化程序设计, C++面向对象, JAVA适应网络环境
- 数据库管理系统 DBMS 是位于用户和操作系统之间的一层数据管理系统(系统软件)，数据库系统 DBS 是指计算机系统引入数据库后的系统，组成：数据库，数据库管理系统，数据库管理员，应用系统
- 软件和硬件在逻辑上是等效的，硬件实现成本低，效率高
- 系统的基本组成：运算器+控制器=CPU，CPU+主存储器=主机，输入/输出设备统称 I/O 设备，又称外部设备
  - 存储器：主存储器和辅助存储器，也称内存储器和外存储器
    - 主存储器存放程序和数据，能被 CPU 直接访问，是实现存储程序控制的基础
    - 辅助存储器用于帮助主存储器记忆更多的信息，必须调入主存后才能被 CPU 访问
    - 存储字长一般为一个字节 8B 或字节的偶数倍
    - 地址寄存器 MAR 存放访存地址，经过地址译码器译码后找到所选的存储单元
    - 数据寄存器 MDR 用于暂存从主存中读或写的信息
    - **MAR 和 MDR 是存储器的一部分，但存在于 CPU 中（地址译码器也在主存中）**

| 存储元、存储元件、存储基元 | 存储单元   | 存储体       | 存储字                 | 存储字长     |
| -------------------------- | ---------- | ------------ | ---------------------- | ------------ |
| 一位二进制                 | 多位二进制 | 许多存储单元 | 存储单元中的二进制代码 | 存储字的位数 |

- 寻址范围

  - 给出存储器容量和字长：eg. 已知计算机字长为 32 位，存储器容量为 1MB
    - 按字节寻址：1MB/1B=1M
    - 按半字寻址：1MB/16bit=512K
    - 按字寻址：1MB/32bit=256K
    - 按双字寻址：1MB/64bit=128K
  - 只给出地址线和数据线的位数：eg. 20 根地址线和 32 根数据线
    - 32 根数据线：存储字长 32 位，即一个存储字有 4 个字节
    - 按字节寻址：20 根地址线范围 2^20^=1M
    - 按字寻址：拿出两根地址线作为字内寻址，寻址范围 2^18^=256K
  - 字地址是所占连续存储单元地址中的最小值
  - 16Kx32 位存储器，地址线 14 根，数据线 32 根
  - 1MB 存储器，地址线和数据线一共 28 根（1Mx8）

- 硬件的基本组成

  - 运算器：对信息进行处理和运算，主要进行算术和逻辑运算，核心是算术逻辑单元 ALU
    - 累加器 ACC、乘商寄存器 MQ、操作数寄存器 X
    - 变址寄存器 IX、基址寄存器 BR、程序状态字寄存器 PSW（状态信息、控制信息）
  - 控制器：
    - 程序计数器 PC：存放当前欲执行指令的地址，可以自动 +1 形成下一条指令地址（PC+1->PC），与 MAR（存储器地址寄存器） 有直接通路
    - 指令寄存器 IR：存放当前的指令，来自 MDR（存储器数据寄存器）
    - 控制单元 CU
    - 指令中的操作码字段 OP(IR)送至 CU，用以分析指令并发出各种微操作命令序列
    - 指令中的地址码字段 AD(IR)送往 MAR 来取操作数
    - 取指阶段访问存储器将指令取出，执行阶段访问存储器将操作数取出，即根据指令周期判断取出什么
    - 操作码送入操作码译码器进行译码，然后与时钟和节拍脉冲发生器合作产生一个时序控制信号，并和操作码译码器的结果一起送入微操作控制器
    - 地址码送入地址形成部件。转移地址送入 PC，操作数地址送入地址译码器取操作数，取出的操作数先放在数据寄存器，然后送往运算器进行运算
    - 每次取指，PC 的内容自动+1
  - 输入/输出设备
  - 冯诺依曼计算机特点
    - 运存控 IO 五大部件
    - 指令和数据同等地位保存在存储器，按地址访问（存储程序的思想）
    - 均用二进制代码表示
    - 操作码+地址码
    - 指令按顺序存放，一般按顺序执行，特定情况下转移指令
    - 以运算器为中心，I/O 设备和存储器之间的数据传送通过运算器完成

- 软件的分类

  - 系统软件（语言处理（汇编、编译、解释）程序、操作系统、服务性程序、数据库管理系统、网络软件等）、应用软件
  - 编程语言分类
    - 机器语言：二进制描述，计算机可以直接识别和执行
    - 汇编语言：英文缩写标识符，直接对硬件操作，程序经过汇编程序(系统软件)的翻译转换为机器语言
    - 高级语言：经过编译程序编译成汇编语言程序，再经过汇编操作得到机器语言程序；或直接由高级语言程序翻译成机器语言程序
  - 汇编程序是用汇编语言编写的程序
  - 解释程序是高级语言翻译程序的一种，解释一句执行一句，不形成目标程序
  - 编译程序先通过翻译转换产生机器语言的目标程序，再让计算机执行目标程序
  - 编译程序产生目标代码的执行速度比解释程序的执行速度要快

- 层次结构

![img](http://image.xmcdn.com/group55/M06/31/12/wKgLf1ycoduyESI6AAKRnmO7n10167.png?op_type=4&device_type=ios&upload_type=attachment&name=mobile_large)

- 计算机性能指标
  - 机器字长指计算机进行一次定点整数运算所能处理的二进制数据的位数，一般等于内部寄存器的大小
  - 吞吐量：信息流入、处理和流出系统的速率，主要取决于主存的存取周期
  - 响应时间：提交作业到得到 CPU 响应的时间，响应时间越短，吞吐量越大
  - 主频：机器内部主时钟的频率，衡量机器速度的重要参数
  - CPU 时钟周期：主频的倒数，CPU 中最小的时间单位，也可称为节拍脉冲或 T 周期
  - CPU 周期：又称机器周期，由取指的最短时间来定义，一个指令周期由若干 CPU 周期组成，一个机器周期由若干时钟周期组成
  - CPI（Clock Cycle Per Instruction）：执行一条指令所需要的时钟周期数
  - IPC（Instructions Per Clock Cycle）：每个时钟周期所执行的指令数
  - MIPS（Million Instructions Per Second）：每秒可执行百万条指令数
  - FLOPS（Floating-point Operations Per Second）：每秒执行的浮点运算次数
    - MFLOPS（Million Floating-point Operations Per Second）：百万 10^6^
    - GFLOPS（Giga Floating-point Operations Per Second）：十亿 10^9^
    - TFLOPS（Tera Floating-point Operations Per Second）：万亿 10^12^
    - PFLOPS（Peta Floating-point Operations Per Second）：千万亿 10^15^
    - EFLOPS（Exa Floating-point Operations Per Second）：百京 10^18^
    - ZFLOPS（Zetta Floating-point Operations Per Second）：十万京 10^21^
  - CPU 执行时间：CPU 对某特定程序的执行时间
  - 时钟中断主要工作室处理和时间有关的信息以及决定是否执行调度程序，和时间有关的所有信息，包括系统时间、进程的时间片、延时、使用 CPU 的时间、各种定时器

# 数据的表示和运算

## 数制和编码

- 二进制（Binary）十进制（Decimalism）八进制（Octal）十六进制（Hexadecimal）

- 二进制优点：

  - 基本符号少，易于用稳态电路实现
  - 二进制的编码、计数、运算等的规则简单
  - 01 与真假对应关系简单

- 真值 →0 表示正号，1 表示负号 → 机器数

- BCD 码（Binary-Coded Decimal）：有权（8421、2421），无权（余三码、格雷码）

  - 8421 码：C 表示+，D 表示-，放在数字串的最后，如+325→0011 0010 0101 1100，十进制位数为偶数时，在高四位补 0
  - 余三码：8421 码+0011，如 9→1001+0011=1100
  - 2421 码：优先使用高位低权码，如 5→1011，而 0101 为非法编码

- 字符代码（Character Code）

  - ASCII 码：共 128 个字符（96 可打印字符+32 控制字符）48-0，65-A，97-a。ASCII 码是 7 位编码，但仍以一个字节来存放一个 ASCII 字符，多余的以为（最高位）通常为 0，数据传输时可用作奇偶校验位
  - 汉字编码：输入编码、汉字内码、汉字字形码
    - 区位码：两个字节表示一个汉字，每个字节 7 位二进制，94x94 二维代码表
    - 国标码=(区位码)~16~+2020H
    - 汉字内码=(国标码)~16~+8080H（最高位都改为 1）
    - 输入码是汉字键盘的输入方法；字模码是汉字的显示图形；区位码是由国家公布的汉字编码，但不直接在机器中使用。在机器中用内码。内码与区位码有固定的公式转换
  - 数据大小端存放，小端存储即以低字节地址为字地址的存放方式

- 校验码：检错编码，纠错编码

  - 奇偶校验码：(水平奇偶校验)添加一位校验码后使得整个码字里面 1 的个数是奇数/偶数，查错能力有限，码距为 2

  - 循环冗余校验（CRC）码：检错率高，开销小，易实现

    1. 信息多项式 M(x)=x^3^+1→1001，生成多项式 G(x)=x^3^+x+1→1011

    2. 将 M(x)二进制左移 G(x)的最高次数，即左移 3 位，得 1001000

    3. 将 1001000 对 1011 做模 2 除法得余数 110，与被除数相加得 1001110，即为 CRC 码

    - 具有 r 检测位的多项式能够检测出所有小于或等于 r 的突发错误（成串出现的特殊错误）
    - 长度大于 r+1 的错误逃脱的概率是 1/2^r^
    - 只有在生成多项式选的非常合适的情况下才具有纠错功能，故默认无纠错功能

  | eg. | M~10~ | M~9~ | M~8~  | M~7~ | M~6~ | M~5~ | M~4~  | M~3~ | M~2~  | M~1~  |
  | --- | ----- | ---- | ----- | ---- | ---- | ---- | ----- | ---- | ----- | ----- |
  | 甲  | D~6~  | D~5~ | P~4~  | D~4~ | D~3~ | D~2~ | P~3~  | D~1~ | P~2~  | P~1~  |
  | 乙  | 1     | 0    |       | 1    | 1    | 0    |       | 1    |       |       |
  | 丙  | 1     | 0    | **1** | 1    | 1    | 0    | **0** | 1    | **0** | **0** |

  - 海明码：具有一位纠错，两位检错能力

    1. 确定校验码的位数 r（数据位数为 k，纠正一位错）：2^r^ - 1 ≥ k + r

    2. 确定校验码的位置：海明码按序 M~N~···M~1~，P~i~的位置为 2^i-1^

    3. 确定数据的位置：数据位按序填入海明码

    4. 求出校验位的值：被校验数据码的海明位号等于校验该数据码的各校验码海明位号之和，且校验码不需要再被校验。校验位 P~i~的值即为所有需要 P~i~校验的数据位求异或

    5. 海明码的校验：假设出错位为 e~1~, e~2~, e~3~, e~4~，如 M~7~下标 7 为 0111，对应 e~4~, e~3~, e~2~, e~1~（倒过来看），故与 e~1~, e~2~, e~3~有关，用异或符号连接

       ​ e~1~ = M~1~⊕M~3~⊕M~5~⊕M~7~⊕M~9~

       ​ e~2~ = M~2~⊕M~3~⊕M~6~⊕M~7~⊕M~10~

       ​ e~3~ = M~4~⊕M~5~⊕M~6~⊕M~7~

       ​ e~4~ = M~8~⊕M~9~⊕M~10~

       若无错，则都为 0；若有错，按 e~4~, e~3~, e~2~, e~1~排序得到二进制序列对应十进制数即出错的位数

    6. 码距：反映的是两个码字不一样的程度（码字对齐后不相同的位数），又称海明距离。许多码字的海明距只看最小的。

    7. L - 1 = D + C 且 D ≥ C

       如果要检测出 d 位错误，D=d，C=0，得 L=d+1，需要一个海明距为 d+1 的编码方案

       如果要纠正 d 位错误，**至少**要检测出 d 位错误，D=C=d，L=2d+1，需要一个海明距为 2d+1 的编码方案

       D≥C：海明码的纠错能力恒小于或等于检错能力

## 定点数的表示和运算

- 定点数的表示：符号位，数码，小数点

  - 无符号数：0 ~ (2^8^ - 1)

  - 有符号数：原码、补码、反码，“0“表示正号，”1“表示负号

    - 3 种机器数的最高位均为符号位

    - 当真值为正数时，原码、补码和反码的表示形式均相同，即符号位用“0”表示，数值部分与真值相同

    - 当真值为负数时，原码、补码和反码的表示形式不同，但其符号位都用“1”表示，数值部分：反码是原码的每位求反(不包括符号位)，补码是原码的每位求反加 1(进位可以改变符号位)

    - |          | 原码                     | 补码                 | 反码                     |
      | -------- | ------------------------ | -------------------- | ------------------------ |
      | +1110    | 0,1110                   | 0,1110               | 0,1110                   |
      | -1110    | 1,1110                   | 1,0010               | 1,0001                   |
      | +0.1101  | 0.1101                   | 0.1101               | 0.1101                   |
      | -0.1101  | 1.1101                   | 1.0011               | 1.0010                   |
      | +0.0000  | 0.0000                   | **0.0000**           | 0.0000                   |
      | -0.0000  | 1.0000                   | **0.0000**           | 1.1111                   |
      | 表示范围 | -(2^n-1^-1) ~ (2^n-1^-1) | -2^n-1^ ~ (2^n-1^-1) | -(2^n-1^-1) ~ (2^n-1^-1) |

      [x]~补~连同符号位在内每位取反，末位加 1，即可得到[-x]~补~

  - 移码：等于补码的符号位取反（即对真值加 2^n^），用移码表示浮点数的阶码，方便判断大小

  - 浮点数$S=e^E*M$

    - r 为浮点数阶码的底，与尾数的基数相等，通常为 2，也可以为 4、8 等
    - E 和 M 都是带符号位的定点数，E 为阶码，M 为尾数，一般尾数为定点小数，用原码或补码表示，阶码为定点整数，用移码或补码表示

  - 用补码表示机器数的优点：可以满足 x+(-x)=0；”0“的补码只有一种；符号位可以和数位一起参与运算；可以将减法转换为加法，只设加法器；可以方便解决补码数的扩充问题，因为-1 的补码永远是全”1“，如扩充成 8 位：1001→11111001，0111→00000111

  - 补码性质：-1 的补码永远全 1，最小负数的补码永远首位为 1 后面全 0，补码比原码和反码多表示一位数

  - 当使用补码表示时，如果符号位相同，则数值位越大，码值越大

  - 负数的补码，以由低位向高位找到第一个 1 时，左边与反码相同，右边(包括这个 1)与原码相同

- 定点数的移码运算

  - 逻辑移位：补 0
  - 算术移位：机器数为正时，都补 0；机器数为负时，原码添 0，反码添 1，补码左移低位补 0、右移高位补 1
  - 机器数为正时，左移高位丢 1，结果出错；右移低位丢 1，影响精度
  - 机器数为负时
    - 原码：左移高位丢 1，结果出错；右移低位丢 1，影响精度
    - 反码：左移高位丢 0，结果出错；右移低位丢 0，影响精度
    - 补码：左移高位丢 0，结果出错；右移低位丢 1，影响精度
  - 若采用双符号位来表示数，最高符号位永远是真正的符号位，在算术移位时只有高符号位保留不变，低符号位要参与移位

- 定点数的加/减运算

  - 原码加法：符号相同，绝对值相加；符号不同，绝对值相减，符号取大。减法：减数符号取反后做加法
  - 补码加减法：符号位参与运算，和的补码等于补码之和$[x+y]_补=[x]_补+[y]_补。[x-y]_补=[x]_补+[-y]_补$

- 溢出：运算结果超过取值范围（需要扩充的数值位改变了符号位）

  - 溢出是对有符号运算说的，当运算结果超出目标操作数所能表示的有符号数范围，称为溢出 Overflow。对于无符号数一般为进位 CarryOut。
  - 上溢、正溢出，下溢、负溢出
  - 单符号位(指补码)
    - 符号位相同，加法运算后改变符号位则溢出
    - 符号位的进位和数值部分最高位的进位异或结果为 1 即溢出（即同时进位或均不进位不溢出）
  - 变形补码：采用双符号位，以 4 为模
    - 符号位连同数值部分一起参与运算，高位符号位产生的进位直接丢弃
    - 高符号位永远代表真正的符号位，据此判断溢出类型
    - 两位符号位不同时表示溢出，01 正溢出，10 负溢出
    - 只存储一位，在相加时，同时送到加法器的两位符号位的输入端

### 定点数的乘法

- 原码一位乘：符号位单独处理（**异或**），参与操作的数是绝对值的原码

  - 两个 n 位数相乘，共需要进行 n 次加法运算和 n 次移位操作
  - 由乘数的末位值确定被乘数是否与原部分积相加，然后右移一位，形成新的部分积
  - 同时乘数也右移一位，由次低位作为新的末位，空出最高位放部分积的最低位
  - 每次加法时，被乘数仅与原部分积的高位相加，其低位被移至乘数所空出的高位位置
  - 所有移位均是**逻辑移位**，高位添 0
  - 部分积在相加中，可能导致两个小数相加大于 1，一般**使用 n+1 位寄存器**

- 原码二位乘：使用三位符号位（防止进位影响到最高符号位）

  - 用 C~j~触发器设置标志位，判断上一轮是否有乘数为 11 的情况下延迟到这一轮的操作
  - 当乘数的位数为偶数时，需做 n/2 次移位，最多做 n/2+1 次加法
  - 当乘数的位数为奇数时，需做 n/2+1 次移位，最多需做 n/2+1 次加法

- **补码一位乘**

  - 当乘数 y 为正数时，不管被乘数 x 的符号如何，都可以按照原码乘法的运算规则来计算，但是移位应该补码的算术移位来操作。

  - 当乘数 y 为负数时，前面同上，并且需要在最后的结果上加上[-x]~补~进行校正

  - 校正法的运算规则收到了乘数符号的限制，一正一负可以通过交换律省去校正

  - 比较法（booth 算法）：在校正法的基础上

    1. 被乘数与部分积一般取双符号位，并且参与运算（校正法中不参与）

    2. 乘数取单符号位以决定最后一步是否需要校正

    3. 乘数末尾增设附件位 y~n+1~，初始值为 0

    4. 根据 y~n~、y~n+1~判断位，进行运算，步骤同上

       | y~n~y~n+1~ | y~n+1~ - y~n~ | 操作                         |
       | ---------- | ------------- | ---------------------------- |
       | 00         | 0             | 部分积右移一位               |
       | 01         | 1             | 部分积加[x]~补~，再右移一位  |
       | 10         | -1            | 部分积加[-x]~补~，再右移一位 |
       | 11         | 0             | 部分积右移一位               |

    5. 按上述算法进行 n+1 步，但是第 n+1 步不再移位，仅根据 y~0~、y~1~比较结果决定是否要加减[x]~补~

    6. 按补码移位规则，右移时正数补 0，负数补 1；双符号位只有次高符号位参与移位

  - [例]已知[x]~补~=1.0101，[y]~补~=1.0011，求[xy]补=？ [-x]~补~=0.1011

    | 部分积初始 00.0000      | 乘数 y~n~ | 附加位 y~n+1~ | 说明                           |
    | ----------------------- | --------- | ------------- | ------------------------------ |
    | +00.1011=00.1011        | 10011     | 0             | 10，加[-x]~补~，右移一位       |
    | 00.0101                 | 1 1001    | 1             | 11，右移一位                   |
    | 00.0010+11.0101=11.0111 | 11 100    | 1             | 01，加[x]~补~，右移一位        |
    | 11.1011                 | 111 10    | 0             | 00，右移一位                   |
    | 11.1101+00.1011=00.1000 | 1111 1    | 0             | 10，加[-x]~补~，最后一步不移位 |

- 补码二位乘：比较 y~n-1~y~n~y~n+1~；部分积和被乘数采用 3 位符号位，乘数采用双符号位；乘数数值位为偶数时，乘数取两位符号位，共需做 n/2 次移位，最多做 n/2+1 次加法，最后一步不移位；乘数数值位为奇数时，可补 0 变为偶数位，也可对乘数取一位符号位，需进行 n/2+1 次移位和 n/2+1 次加法

- 两个定点小数相乘，不可能会溢出，两个绝对值小于 1 的数相乘，结果的绝对值不可能大于 1

- 两个定点整数相乘可能会溢出，溢出的条件：乘积＞定点格式表示的最大数

### 定点数的除法

- 原码恢复余数法：讨论定点纯小数，被除数、除数、尚都是绝对值小于 1 的定点小数

  - 原码运算的符号位通通单独处理，取除数和被除数的绝对值的补码运算
  - 判断是否满足 0<|被除数|<|除数|（若是定点纯整数除法，应满足 0<|被除数|≤|除数|）
  - 若余数为正，商上 1(从第二次开始，第一次必定是 0)，左移一位，加上[-y]~补~
  - 若余数为负，商上 0，恢复余数(加上除数)，左移一位，加上[-y]~补~
  - 重复 n 次，若最后一步余数为负，需要恢复余数
  - 具有 n 位尾数的合法除法，需要逻辑移位 n 次，上商 n+1 次，结果商需要乘 2^-n^进行恢复

- 原码不恢复余数法（加减交替法）

  - 余数大于 0，左移一位，减去除数（即加上[-y]~补~）
  - 余数小于 0，左移一位，加上除数（相当于先恢复余数，再左移，再减）
  - 最后一步仍需恢复

- 左移余数可以用右移除数代替，但右移除数线路比较复杂，所以不使用

- 补码不恢复余数法（加减交替法）

  ![截屏2020-10-10 下午5.04.31](/Users/P1anet/Desktop/截屏 2020-10-10 下午 5.04.31.png)

  - n 位小数补码乘法共上商 n+1 次（包括商末位恒置 1），移位 n 次，加法 n+1 次

- 判断溢出方法：原码第一次上商 1 为溢出；补码第一次上商的商值（即商的符号位）与两个操作数的符号位异或结果进行比较，不同则溢出。

- 计算机内部的填充（扩展）操作

  - 无符号整数：高位补 0，零扩展
  - 有符号定点整数：原码符号位不变，数值部分高位补 0；补码高位直接补符号，符号扩展
  - 对定点小数表示的浮点数的尾数：在低位补 0

## 浮点数的表示和运算

### 浮点数的表示

- 阶码的底 r 省略

- 阶符和阶码的位数 k 合起来反映浮点数的表示范围及小数点的实际位置

- 尾数 M 的位数 n 反映了浮点数的精度

- 位数的符号 m~s~表示了浮点数的正负

- 尾数为纯小数，用**原码**或补码表示；阶码为定点整数，用补码或**移码**表示

  |          | 数符 S | 阶码 | 尾数(有效位数) | 总位数 | 最大指数 | 最小指数 | 偏移量 |       |
  | -------- | ------ | ---- | -------------- | ------ | -------- | -------- | ------ | ----: |
  | 短实数   | 1      | 8    | 23（24）       | 32     | +127     | -126     | +127   |   7FH |
  | 长实数   | 1      | 11   | 52（53）       | 64     | +1023    | -1022    | +1023  |  3FFH |
  | 临时实数 | 1      | 15   | 64（64）       | 80     | +16383   | -16382   | +16383 | 3FFFH |

- 对短/长实数，整数位的 1 省略，称为隐藏位；临时实数不采用隐藏位

- 对于阶码为 0 或 255 的情况，[IEEE754 标准](https://www.baidu.com/s?wd=IEEE754标准&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1dBnWI-uADkn1bzuWDvmWnY0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPHbsrjfsrHbz)有特别的规定

  ​ 如果 E 是 0 并且 M 是 0，则这个数的真值为 ±0（正负号和数符位有关）

  ​ 如果 E = 255 并且 M 是 0，则这个数的真值为 ±∞（同样和符号位有关）

  ​ 如果 E = 255 并且 M 不是 0，则这不是一个数（NaN）

- 规格化数：假设尾数为 W，基数为 2，则**1>|W|≥1/2，即 r^0^>|W|≥r^-1^**(r 为基数时，尾数的最高 log~2~t 位不全为 0

  - 原码表示：尾数第一位必须为 1 0.1······，1.1······
  - 补码表示：正数最高位必须为 1，负数最高位必须为 0 00.1······，11.0······
  - -1/2 的补码 11.100···0，不是规格化数（1/2 是）
  - -1 的补码 11.00···0，是规格化数

- |          | 非规格化浮点数            | 规格化浮点数(原码)        | 规格化浮点数(补码)          |
  | -------- | ------------------------- | ------------------------- | --------------------------- |
  | 最大正数 | $2^{(2^m-1)}*(1-2^{-n})$  | $2^{(2^m-1)}*(1-2^{-n})$  | $2^{(2^m-1)}*(1-2^{-n})$    |
  | 最小正数 | $2^{-(2^m-1)}*2^{-n}$     | $2^{-(2^m-1)}*2^{-1}$     | $2^{-2^m}*2^{-1}$           |
  | 最大负数 | $-2^{-(2^m-1)}*2^{-n}$    | $-2^{-(2^m-1)}*2^{-1}$    | $2^{-2^m}*(-2^{-1}-2^{-n})$ |
  | 最小负数 | $-2^{(2^m-1)}*(1-2^{-n})$ | $-2^{(2^m-1)}*(1-2^{-n})$ | $2^{(2^m-1)}*(-1)$          |

### 浮点数的加/减运算

- 对阶，使两数的小数点位置对齐（低阶向高阶对）
- 尾数求和，将对阶后的两尾数按定点加/减运算规则求和或者求差
- 规格化，为增加有效数字的位数，提高运算精度，必须将求和或求差后的尾数规格化 **左减右加**
  - 00.0······或 11.1······：左规，阶码-1，次数不确定
  - 01.······或 10.······：右规，阶码+1，只需要一次
- 舍入，为提高精度，要考虑尾数右移时丢失的数值位
  - 0 舍 1 入法：去 0 舍去，去 1 则尾数+1，可能导致尾数溢出，则再做右规
  - 恒置 1 法：无论丢 1 还是 0，都使右移后的尾数末位恒置 1
- 判断是否溢出。阶码 01：＞最大正阶码，上溢，中断处理；阶码 10：＜最小负阶码，下溢，按机器零处理
  - 左规不会溢出，右规要看阶码情况
  - 机器零指 0 点及附近的一段区域，只有以移码表示阶码时，才能用全 0 表示机器零的阶码
    - 尾数全为 0 或阶码小于有效范围的最小值

### 浮点数的乘除法

- 阶码相加减，尾数相乘除，不用考虑对阶，但要考虑规格化和舍入

数据类型的转换：短字长转为长字长，定点数转为浮点数，有符号与无符号数之间机器数不变，只是看待符号位的角度不同，真值随之不同

## 算术逻辑单元 ALU

- 全加器：三端输入，两端输出；半加器：两端输入，两端输出，不需要进位信号的输入。2\*半加器 → 全加器

- 串行加法器：只设一个全加器，操作数分别放在两个移位寄存器中，从低位到高位串行地提供操作数进行相加。每一步的和串行地送入结果寄存器，产生的进位信号只需要一位触发器

- 并行加法器：串行进位链：进位函数$C_i=A_iB_i+(A_i\bigoplus B_i)C_{i-1}$；并行进位链：

  - 单重分组跳跃进位链：代入法迭代，组内并行，组件串行
  - 双重分组跳跃进位链：组内并行，组间也并行。小组内的其他进位与小组的最高进位不是同时产生的

- 组合逻辑电路：任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关（结果要立即送入寄存器

- 时序逻辑电路：不仅取决于当时的输入信号，还取决于电路原来的状态（具有记忆元件，记录前一时刻的输出

- ALU 是一种组合逻辑电路，其输入端口与锁存器相连，运算过程中锁存器内容不变，输出需送至寄存器保存

  - 锁存器：多为触发器，用作运算器中的数据暂存器

- 主要功能：算术与逻辑运算，具有先行进位逻辑

  - 74181 芯片是 4 位的 ALU 电路，可用 4 片 74181 芯片组成一个 16 位全加器按 4 位一组的单重分组跳跃进位链

    74181 芯片可完成 16 种算术运算和 16 种逻辑运算

  - 使用 74182 芯片—先行进位部件实现 74181 间的并行进位。2 片 74182 和 8 片 74181 可组成 32 位的双重分组跳跃进位链，4 片 74182 和 16 片 74181 可组成 64 位的双重分组跳跃进位链

- 正逻辑：高 1 低 0；负逻辑：高 0 低 1。不能混合使用

# 存储器

## 基本概念

- 按存储介质
  - 半导体存储器：随机存储器，只读存储器
  - 磁表面存储器：磁盘，磁带
  - 光盘存储器：光存储器，光盘 CDROM
  - 磁芯存储器：已被半导体存储器取代
- 按存取方式
  - 随机存取存储器（Random Access Memory, RAM）易失性存储器
    - 优点：读写方便，使用灵活；缺点：断电信息丢失
    - （静态）SRAM 用作高速缓冲存储器，（动态）DRAM 用作主存
  - 只读存储器（Read-Only Memory, ROM）非易失性存储器
    - MROM 掩膜型只读存储器（制造时写入，元件有无）
    - PROM 可编程只读存储器（一次性写入，熔丝）
    - EPROM 光可擦除可编程只读存储器（使用紫外线**全部**擦除，悬浮栅）
    - EEPROM 电可擦除可编程只读存储器（使用高压，既可局部擦除，也可以全部擦除）
    - Flash Memory 快擦除读写存储器，闪存（也可单独拿出来作为一类）
  - 串行访问存储器
    - 顺序存取存储器：磁带
    - 直接存取存储器：磁盘（半串行，寻道随机访问，道内串行访问）
- 按作用：主存，辅存（外存），Cache（高速缓存）
- 性能指标：速度越高，价格越高；容量越大，价格越低，速度也越低。理想大容量、高速度、低价格

  - 存储容量=存储字数 x 存储字长。存储字数表示存储器的地址空间大小即存储器的存储单元数目
  - 单位成本：每位价格=总成本/总容量
  - 存储速度：数据传输率=数据的宽度/存储周期。存储周期又称读写周期或访问周期，指连续两次独立地访问存储器操作之间所需的最小时间间隔；存取时间指启动一次存储器操作到完成该操作所经历的时间，一般小于存储周期（需要复原时间）

- 层次化结构
  - CPU 能和缓存、主存交换信息，缓存能和 CPU、主存交换信息；主存可以和 CPU、缓存、辅存交换信息
  - 缓存-主存层次主要解决 CPU 和主存速度不匹配的问题，数据交换由硬件自动完成，对程序员透明
  - 主存-辅存层次主要解决存储系统的容量问题，数据交换由硬件和操作系统共同完成
  - 存储器带宽是衡量数据传输速率的重要指标，表示单位时间内存储器存取的信息量
  - 寄存器-缓存-主存-磁盘-光盘-磁带

## 半导体随机存取存储器

- 由存储矩阵、译码驱动电路和读/写电路组成

- 地址线单向，数据线双向，控制线有读/写控制线和片选线

- 译码驱动方式

  - 线选法（单译码）：选中一字。矩阵有 N 行，需要$\lceil log_2N\rceil$根地址线，每行 m 位，需要 m 根数据线
  - 重合法（双译码）：选中一位。如 32x32 矩阵需要行和列地址线各 5 根

- 74138译码器

- SRAM

  - 保持存储信息：使用六管静态 MOS 存储单元电路，利用**双稳态触发器**保存信息
  - 读数据：送地址且发读命令
  - 写数据：需要传输地址信号和数据信号，$\overline{W}$读 0 写 0 高电平，$W$读 1 写 1 低电平

- DRAM

  - 保持存储信息：分**多管型和单管型**，遵循**电容存储电荷**的原理

  - 读数据：W 有电流 1，无电流 0

  - 写数据：W 高电平写 1，低电平写 0

  - DRAM 采用地址复用技术，地址线是原来的一半，地址信号分为行和列两次传送

    - 读(写)周期指两次连续读(写)操作的最小时间间隔，读(写)时间表示进行一次存储器读(写)操作的时间
    - 读/写/存储时间小于读/写/存储周期（恢复时间）

  - 刷新\再生：电容中存储的电荷不能永久保留，默认 2ms 内必须刷新一次

    - 存储体是矩阵形式，每次刷新都是对行刷新

    - 若没有特别说明刷新的细节，**刷新一行所需的时间就是一个存储周期**；如果说明刷新操作由读操作和写操作一起执行，那么刷新一行的时间按照两倍的存储周期计算

      1. 集中刷新：2ms 为一个刷新周期，其中刷新时间称为死时间，又称访存死区，可计算死时间率

      2. 分散刷新：存储周期=读或写周期+刷新一行的时间，认为延长存储周期，降低了系统速度

         分散刷新中由于刷新时间包含在存储周期内，故不存在死时间（需要在存储周期外，且连续）

      3. 异步刷新：把每行平均地分配到 2ms 时间内刷新，总死时间是一个读/写周期（不累加）缩短了死时间，提高了整机速度

      4. 透明刷新：刷新安排在译码阶段，不存在死时间

      缩短死时间的方式有很多，如在 CPU 指令译码阶段进行刷新等

    - 刷新行号由 DRAM 的刷新控制电路中的刷新计数器产生，整个存储器所有芯片的相同行同时进行刷新

    - 刷新是按顺序定时一行一行进行；再生是随机的，只对所读单元进行（破坏性读出后要跟上一个再生

- Flash 存储器

  - E^2^PROM 的演进，本质上属于 E^2^PROM，集合了 RAM 和 ROM 的长处，非易失性，可写，写入前要先擦除，故写比读慢。一般按块来读取数据，而不是字节。SSD 通常由 Flash 芯片组成

- 比较

  - SRAM：非破坏性读出，不需要刷新。断电信息即丢失，易失性存储器。**存取速度快**，集成度低，**功耗较大**，常用于 Cache
  - DRAM：破坏性读出，**需要刷新**。断电信息即丢失，易失性存储器。**集成度高，价位低，容量大，功耗低**。存取速度比 SRAM 慢，常用于大容量的主存系统
  - SRAM：地址线+数据线+片选信号+写允许信号+电源端+接地端
  - DRAM：地址线（采用地址复用为一半）+数据线+行选通信号+列选通信号+写允许信号+输出允许信号+电源端+空引脚
  - RAM 读周期：存储芯片进行两次连续读操作时，必须间隔的时间，读周期总是大于等于读出时间
  - RAM 写周期：数据总线上的信息能够可靠的写入存储器
  - ROM：通常只能读出不能写入，永久保存，随机存取，非易失性存储器。分两次传地址。ROM 和 RAM 可同作为主存的一部分，构成主存的地址域，ROM 存放系统程序，RAM 组成用户区(开机后将 ROM 中系统程序读入 RAM 的系统区？引导程序...)

## 主存与 CPU 的连接

存储器容量的扩充：

- 位扩充：并联，共用地址线，数据线扩充，共用片选信号线$\overline{CS}$和读/写信号线$\overline{WE}$
- 字扩充：串联，每个芯片和所有数据线连接，用片选信号线区分不同的芯片，CPU 的地址线比存储芯片的地址线多，多出来的地址线用作片选信号（通过非门同时控制两个芯片的片选）
- 字位扩充：先进行位扩充，在进行字扩充，片选信号由译码器产生
- 存储器校验一般用海明码
- 部分译码：有多余的地址线没用，会出现歧义（一个存储单元对应多个地址）

## 双口 RAM 和多模块存储器

- 双口 RAM：具有两组独立的地址线、数据线和读/写控制线，可以并行的独立操作，设置 BUSY 标志防止冲突
- 单体多字存储器：前提是指令和数据在主存内连续存放
  - 把存储器的存储字长增加 n 倍，相应数据线宽度也必须增加 n 倍，以存放 n 个指令字或数据字，于是最大带宽相比于单体单字存储器提高 n 倍
  - 缺点：需要凑齐 n 个数据字之后才能作为一个存储字一次写入存储器
- 多体并行存储器：每个模块有相同的容量和存取速度，有独立的 MAR，MDR，地址译码器和读/写电路
  - 高位交叉编址：又称顺序存储，每个模块的体内地址顺序是连续的，一个体存满后再存入下一个体
    - 高位地址表示体号，低位地址定位体内地址，可以实现不同请求源并行访问不同的体
    - 优点：非常利于存储器的扩充，只需将存储单元的编号往后加
    - 缺点：模块间串行工作，限制了存储器的带宽，不满足程序的局部性原理
    - t~2~=nT
  - 低位交叉编址：又称**交叉存储**，连续地址分布在相邻的不同模块，同一个模块内的地址都是不连续的
    - 低位表示体号，高位定位体内地址，实现同一请求源并行地访问不同的体
    - 各模块有独立的读写控制电路，地址寄存器和数据寄存器
    - 对于连续字的成块传送，可以实现多模块流水线式**并行**存取，大大提高存储器的带宽
    - t~1~=T+(n-1)τ，块数 n 应大于等于 T/τ（流水线）
- 突发(猝发)传送，指送出一个数据块的首地址，以后不再需要给出每一个存储单元的地址，而是连续读写此块中所有的数据，因此要求数据是连续存放的。**一次传输一个地址和一批地址连续的数据**
- 为防止两个及以上的请求源同时占用同一个存储体，并防止将代码错送到另一个请求源等各种错误的发生，需设置一个排队器，确定请求源的优先级别。Cache 最高，其次是严重影响 CPU 工作的请求源

## 高速缓冲存储器 Cache

- 局部性原理：时间和空间
- Cache 一般采用高速的 SRAM 制作（主存一般用 DRAM），其价格比主存高，容量远比主存小
- 主存和 Cache 的编址：块的大小要相同
  - 命中率：CPU 要访问的信息在 Cache 中的比例
  - 平均访问时间（全概率公式）
  - Cache 主存系统效率=命中时访问 Cache 的时间/平均访问时间
    - H=Nc/(Nc+Nm), r=Tm/Tc, e=1/[H+r(1-H)]
  - CPU 和 Cache 之间传送数据的基本单位是字，Cache 和主存之间是块
  - CPU 访问主存时，会将地址同时送给 Cache 和主存，Cache 控制逻辑判断此字是否在 Cache 中，若在，立即传送给 CPU；否则，主存将此**字**读出并送到 CPU，并将含有此字的**整个数据块**读出并送到 Cache
- 多级 Cache 系统：L1 指令和数据分开存放（data Cache 和 code Cache），L2 放在一起
- Cache 存放的是主存信息的副本，计算机的总存储容量并未增加
- Cache 的访问过程对程序员是透明的，由 CPU 自动完成
- 基本结构：地址映射变换机构，替换机构
- 块越大，第一次启动产生的失配率也越小。多级 Cache 可以减少由于 Cache 容量有限造成的失配。指令与数据有不同的访问规律，Cache 分设可提高命中率。

### Cache 和主存之间的映射方式

主要是块号之间的转换（块大小相同，块内地址都是相对于块起始地址的偏移量）

- 直接映射 `主存字块标记 | Cache字块地址 | 字块内地址`

  - 优点：实现简单，判断方便
  - 缺点：不够灵活，存储空间不能充分利用；冲突概率高（抖动），某个块频繁地交换
  - 应用场景：适合大容量 Cache
  - 操作原理：CPU 访存指令取出内存地址（包含 tag，块号，字等），根据块号找到 Cache 对应块号，将其中标记域 tag 比较，若相符且有效位为 1，则命中；若不命中，则替换块，送字，修改标记

- 全相联映射 `主存字块标记 | 字块内地址`
  - 如主存有 256 块，Cache 分 8 行，Cache 需要 8 位(2^8^=256)作标记位识别每一个主存块；而直接映射只需要识别组号，由主存分为 256/8=32 组，即 Cache 需要 5 位作为标记位识别块属于哪一组
  - 优点：命中率提高；减少了块的冲突率，提高了 Cache 的利用率
  - 缺点：tag 的位数增加，访问 Cache 时主存字块标记需要和 Cache 的全部标记进行比较，通常用按内容寻址的相联存储器来完成
  - 应用场景：适用于小容量的 Cache
  - 操作原理：为了加快检索速度，将 Cache 所有行的标记位和内存地址的块号一同送入比较器中比较...
- 组相联映射 `主存字块标记 | 组地址 | 字块内地址`

  - 将 Cache 分组，组间直接映射，组内全相联映射。组数=1 时 → 全相联；每组 1 块时 → 直接映射
  - 如 Cache 分为 4 组，则主存分为 256/4=64 组，需要 6 位 tag 表示组号
  - 块内字地址 offset=log~2~（块大小），组号 index=log~2~（Cache 组数），标记 tag=主存地址的其余位
  - 每组有 N 块，则称为 N 路组相联，LRU 替换控制位 log~2~N 位

- 每一个 Cache 行对应一个标记项（包括有效位 1bit、标记位 Tag(等于主存地址中的标记字段)、一致性维护位(脏位)1bit、替换算法控制位），组相联一组标记项构成一行，各组构成标记项阵列；另两种一行标记项就是一组

### Cache 中主存块的替换算法

- 先进先出算法（FIFO）：容易实现，开销小；没有用到局部性原理，不能提高命中率
- 最近最久未使用算法（LRU）：替换出近期用得最少的字块，记录**每个块**最近一次使用的时间。平均命中率高（堆栈类算法）
- 最近最少使用算法 LFU
- 随机法 RAND

### Cache 写操作策略

- 写命中：全写法 write-through，写回法 write-back；写不命中：写分配法 write-allocate，非写分配法 not-write-allocate

  - 全写和非写分配，写回和写分配

- 写回法：当 CPU 写 Cache 命中时，只修改 Cache 的内容，只有当此行被换出时才写回主存
  - 对 Cache 每行都设置一位修改位(脏位)，决定写回内存还是简单丢弃
  - 当不命中时，从主存中找出字所在数据块，复制到 Cache 中修改，当换出时再写回主存
- 全写法，写直通法：命中时，同时改写，保持了 Cache 和主存内容的一致性
  - 不需要每行都设置修改位，未命中时直接在主存中修改，是否复制到 Cache 视情况而定
- 写一次法：和写回法基本相同，仅仅第一次写命中时要同时写入主存
- 写分配法：空间局部性，加载主存中的块到 Cache 中，然后更新 Cache 块，每次不命中都要从主存调块
- 非写分配法：只写入主存，不进行调块

## 虚拟存储器

- Cache 用硬件实现，对操作系统透明；虚拟存储器用操作系统和硬件相结合的方式实现
- Cache 是一个物理存储器，虚拟存储器是一个逻辑存储器，物理结构建立在主存-辅存结构基础上
- 作用是分隔地址空间，解决主存的容量问题和实现程序的重定位
- 虚拟存储器的容量由计算机地址总线的数量来决定，最大可设置为主存+磁盘的容量
- 页式虚拟存储器
  - 基本单位为页，需要通过地址变换机构实现访存过程，页面不在主存时，通过页面置换算法调入主存
  - 优点：起点终点地址固定，因此页表简单，调入方便，主存空间浪费小
  - 缺点：页面不是逻辑上的独立实体，处理、保护和共享不如段式方便
- 段式虚拟存储器
  - 基本单位为段，通过地址变换机构实现访存过程
  - 优点：段的分解与程序的自然分解相对应；段的逻辑独立性使它易于编译、管理、修改和保护，也利于多道程序共享；某些类型的段（堆栈、队列）具有动态可变长度，允许自由调度以便有效利用主存空间
  - 缺点：段的长度各不相同，起点和终点不定，给主存空间分配带来麻烦，且容易在段间留下不易利用的零碎存储空间，造成浪费
- 段页式虚拟存储器
  - 程序按逻辑单位分段后，再把每个段分成固定大小的页，按页面进行对主存的调度，按段实现共享和保护
  - 优点：兼备页式和段式虚拟存储器的优点
  - 缺点：在地址映射过程中需要多次查表
- TLB 快表
  - 利用局部性原理，将页表分为快表（相联存储器），慢表 Page（主存中）
  - 查找时快表和慢表**同时进行**，TLB 是 Page 的一个很小的副本
  - 辅存和 CPU 没有直接通路，虚拟存储器不命中时，只能先从硬盘调入主存，CPU 不能直接从硬盘读取数据
  - 快表通常采用全相联或组相联，分组后虚页号中：高位为 TLB 标记，低位为组索引
- 逻辑地址（虚拟地址）→ 物理地址 → 最终地址（Cache 命中，则为 Cache 中的地址）
- 命中一致性：如果 TLB 命中，页表必然命中，且该页面一定在内存中；Cache 命中与页表命中没有必然关系，但 TLB 和页表均不命中的情况下，Cache 不可能命中（数据不在主存）
- 不同之处
  - Cache 解决系统速度问题，虚存解决主存容量问题
  - Cache 全部由硬件实现，虚存由 OS 和硬件共同实现
  - Cache 对所有程序员透明，虚存对应用程序员透明，对系统程序员不透明
  - 虚存不命中对系统性能影响更大
  - CPU 只能与 Cache 和主存直接交互，虚存只能先将数据从硬盘调入主存，不能与 CPU 直接通信

## 外存储器

- 硬盘存储器：记录介质为硬质圆形盘片的磁表面存储设备

  - 记录数据方式：归零制（RZ），不归零制（NRZ）；遇 1 翻转的不归零制（NRZ1）
  - 技术指标：
    - 记录密度：单位长度内存储的二进制信息量。
      - 道密度：半径方向单位长度的磁道数，道距：相邻磁道间的距离
      - 位密度/线密度：单位长度磁道能记录二进制信息的位数
      - 所有磁道记录的信息量相等，不因半径改变。最大位密度即最内层圈的位密度
    - 存储容量 = 盘面数 x 磁道数 x 磁道代码数
    - 平均寻址时间 = 平均寻道时间 + 平均等待时间
    - 数据传输速率：单位时间磁表面存储器向主机传输数据的位数或字节数，与记录密度和磁盘转速有关
    - 误码率：出错位数/总位数，常用 CRC 码来校验数据
  - 由磁记录介质，磁盘控制器和磁盘驱动器三大部分组成
  - 按是否具有可换性分为**可换盘**磁盘存储器和**固定盘**磁盘存储器
  - 按工作方式分为**固定磁头**磁盘存储器和**移动磁头**磁盘存储器
  - 磁道记录格式分为定长记录格式和不定长记录格式
  - 磁盘地址的设计：台号（磁盘号），磁道号（柱面号），磁头号（盘面号），扇区号
    - 将 n 个盘面上同一半径的磁道存储的信息称为柱面信息，信息交换在柱面上进行，柱面个数=磁道数，故柱面号就是磁道号，磁头号是盘面号
    - 扇区是磁盘寻址的最小单位，每个扇区有一个记录块包含地址标识字段、数据字段(512B)、校验字段
    - 一个系统中有多组磁盘组，每组的编号称为台号
    - eg. 有 11 个盘片，则有 20 个记录面可用
    - 台号确定后，先确定柱面(寻道时间)，再选定磁头(找到盘面)，最后找扇区(等待时间)

- 磁盘阵列（RAID 廉价冗余磁盘阵列，Redundant Arrays of Inexpensive Drives）
  - 用多个小容量磁盘代替大容量磁盘（分块，并行处理
  - RAID0：读写都分成数块存入不同的磁盘，速度加快但可靠性不高
  - RAID1：镜像备份，写入时同时写到阵列中的每一个磁盘，容错性好
- 光盘存储器
  - 用激光在某种介质上写入信息，然后利用激光读出信息的技术称为光存储技术
  - 第一代：非磁性介质，不可修改；第二代：磁性介质，可擦除重写
  - 只读型光盘 CD-ROM，只写一次型光盘，可擦写型光盘
  - 非接触式读写信息，大大提高耐用性；光道、扇区，扇区也是最小可寻址单位

# 指令

- 指令格式
  - 操作码：分为定长操作码和不定长操作码（又称扩展操作码或变长操作码）
    - 定长操作码：最高位部分分配固定若干位表示操作码
    - 不定长操作码：前缀码，高频指令短操作码...（哈夫曼思想）
  - 寻址特征
  - 地址码：也称操作数字段，指出操作数的地址、运算结果存放的地址、下一条指令的地址
    - 地址码可以是操作数本身、操作数地址或操作数地址的计算方法
- 按指令功能分类

  - 算术和逻辑运算指令
  - 移位指令：算术和逻辑移位
  - 数据传送指令：CPU 和主存之间，统一编址下也可以完成 CPU 和 I/O 设备的数据传送
  - 转移指令、子程序调用与返回指令
  - 其他指令：如停机指令，开关中断指令等

- 按操作数个数分类

  - 零地址指令
    - 不需要操作数的指令，如空操作指令、停机指令、关中断指令
    - 只有堆栈计算机中有零地址运算类指令。操作数隐含的从栈顶和次栈顶弹出，结果隐含地压入栈中，包括硬堆栈（寄存器）和软堆栈（内存）
  - 一地址指令
    - 只有目的操作数的单操作数指令（逻辑运算）。OP(A~1~)→A~1~，如加 1、减 1、求反、求补等
    - 隐含约定目的地址的双操作数指令（算术运算）。另一个操作数由 ACC 提供，结果也放在 ACC 中，(ACC)OP(A~1~)→ACC
  - 二地址指令 (A~1~)OP(A~2~)→A~2~：RS, RR, SS
    - 8086CPU 不支持 SS
  - 三地址指令 (A~1~)OP(A~2~)→A~3~
  - 四地址指令 (A~1~)OP(A~2~)→A~3~，A~4~是下一条将要执行指令的地址（不用访存）
  - 指令字长指一条指令占用存储空间的大小，一般为字节的整数倍，若等于**机器字长**，则称为单字长指令...
  - 指令字长通常取**存储字长**的整数倍，与机器字长无必然联系
  - 用 PC，ACC 等硬件减少指令字中需指明的地址码，可以不改变指令字长的前提下，扩大指令操作数的直接寻址范围；也可以缩短指令字长以及减少访存次数（访问寄存器）

- 指令的寻址方式，有效地址 EA 指真实地址

  - 指令寻址：找到下一条将要执行指令的地址，存到 IR
    - 顺序执行：(PC)+1
    - 跳转执行：转移指令寻址，计算出目标地址，送到 PC
  - 数据寻址：找到当前正在执行指令的数据地址
    - 寄存器，内存单元，堆栈，I/O 端口，立即数
    - `操作数|寻址特征|形式地址(A)`

  1. 立即寻址：`OP # A` 直接给出操作数，常用于对某寄存器或内存单元赋初值
  2. 直接寻址：EA=A，如 LDA A
  3. 隐含寻址：`ADD A` 一地址格式的**算术运算指令**的另一个操作数隐含在 ACC 中，增加存储操作数或隐含地址的硬件
  4. **间接寻址**：`OP A` 给出操作数有效地址的地址，用于寻找中断服务程序的入口
     1. 一次间接寻址 EA=(A)，范围是 2^存储字长^
     2. 多次间接寻址需要使用一位来标志是否间址完毕，范围 2^存储字长-1^
     3. 优点：便于子程序返回和查表，扩大了寻址范围，方便编制程序。缺点：N 次间接寻址需要访问存储器 N+1 次
  5. 寄存器寻址：地址码字段直接给出寄存器编号 R~i~，EA=R~i~
     1. 减少了指令字的长度；执行阶段不需要访存
  6. 寄存器间接寻址：R~i~的内容是操作数所在主存单元的地址号，EA=(R~i~)，便于编制循环程序
  7. 基址寻址：EA=A+(BR)，BR 基址寄存器，可显式或隐式给出
     1. 优点：扩大操作数的寻址范围（BR 位数）；**便于解决多道程序问题**
     2. BR 的内容**由 OS 确定**，在程序执行过程中用户不能随意改变，但可以知道哪个通用寄存器用作了 BR
  8. 变址寻址：EA=A+(IX)，IX 变址寄存器
     1. 变址寄存器的内容**由用户设定**，在程序执行过程中其值可变
     2. 优点：扩大操作数的寻址范围（IX 的位数大于 A 的位数）；**非常适合处理数组问题和编制循环程序**
     3. 常与其他寻址方式结合使用，如 EA=(A)+(IX)或 EA=(A+(IX))
     4. 基址寻址和变址寻址的区别：在基址寻址中，程序员操作的是偏移地址，BR 的内容由 OS 控制，在执行过程中动态调整；变址寻址中，程序员操作的是 IX，偏移地址固定不变
  9. 相对寻址：基于程序局部性原理 EA=(PC)+A
     1. 基址寻址、变址寻址、相对寻址都可以看成是偏移寻址
     2. 用于转移类指令，便于编制浮动程序
  10. 小结规律
      1. 指令的地址码字段可能是：寄存器编号、设备端口地址、存储器的单元地址、数值
      2. 指令的操作数可能存放在：寄存器，I/O 端口，内存单元，指令中（立即数），堆栈区
      3. 返回指令不一定要有地址字段（返回地址保存在堆栈中的情况，直接从栈顶取）

- **CISC**和**RISC**（Complex/Reduced Instruction Set Computer

  - RISC：选取使用频率较高的一些简单指令和一些很有用但不复杂的指令(寄存器型指令)，让复杂指令的功能由使用频率较高的简单指令的组合来实现
    - 指令长度固定，指令格式种类少，寻址方式种类少
    - 只有取数 load/存数 store 指令访存，其余指令的操作都在寄存器内完成
    - CPU 中有多个通用寄存器（多于 CISC）
    - 采用流水线技术(必须)，大部分指令在**一个时钟周期**内完成。采用超标量和超流水线技术，可使每条指令的平均执行时间小于一个时钟周期
    - 控制器采用**组合逻辑**控制，不用微程序控制
    - 采用优化的编译程序
  - CISC：指令系统复杂庞大，一般多达 200~300 条
    - 指令长度不固定，指令格式种类多，寻址方式种类多
    - 可以访存的指令不受限制
    - 由于 80%的程序使用其 20%的指令，各指令的使用频率差距太大
    - 各种指令执行时间相差很大，大多数指令需要多个时钟周期
    - 控制器大多数采用**微程序**控制
    - 难以用优化编译生成高效的目标代码程序
  - 比较
    - RISC 比 CISC 更能提高计算机的运算速度（减少访存次数；指令译码较快）
    - RISC 比 CISC 更便于设计，可降低成本，提高可靠性
    - RISC 只是 CPU 的结构发生变化
  - RISC 能有效支持高级语言程序，CISC 处理特殊任务效率较高

- MIPS 指令集：寄存器...指令格式：R，I，J...寻址方式...

# 中央处理器

- 功能：指令控制，操作控制，时间控制；数据加工；中断处理

- 基本结构：CU，ALU，中断系统，寄存器，内部总线

- 运算器中的寄存器**加粗为用户可见的寄存器**

  - 算术逻辑单元 ALU
  - 暂存寄存器 DR：暂存从主存读来的数据，不能放在通用寄存器中，对应用程序员透明
  - **累加寄存器 ACC**：是一个通用寄存器。为 ALU 提供工作区，暂时存放 ALU 运算的结果信息
  - **通用寄存器组**：用于存放操作数和各种地址信息，AX,BX,CX,DX 以及堆栈指针 SP，对程序员不透明
  - **状态条件寄存器 PSW**：也叫程序状态字寄存器，保存由算术指令和逻辑指令运行或测试的结果建立的各种条件码内容，如进位标志 C，溢出标志 V，零标志 Z，负标志 N，通常由一位触发器保存；还可以保存中断和系统工作状态等信息
  - 移位器，计数器

- 控制器中的寄存器
  - **程序计数器 PC**：又称指令计数器，具有寄存信息和计数两种功能，程序员可见
  - 指令寄存器 IR：保存当前正在执行的指令。操作码送入指令译码器，地址码送往地址形成部件，形成的有效地址送往主存的地址寄存器，对于转移指令，送到 PC。控制器根据操作码译码结果发出控制信号
  - 指令译码器
  - 存储器数据寄存器 MDR：也叫数据缓冲寄存器，暂存由主存读出或要向主存写入的一条指令或一个数据字
    - 作为 CPU、内存和外设之间信息传送的中转站，补偿他们之间的操作速度上的差别
    - 在单累加器结构的运算器中，还可兼作操作数寄存器
  - 存储器地址寄存器 MAR：保存当前 CPU 访问的内存单元的地址（由于操作速度上的差距）
  - 时序系统，微操作信号发生器
- 指令执行过程
  - 指令周期：CPU 完成（取出并执行）一条指令所需的全部时间
  - 指令执行方案：单指令周期，多指令周期，流水线方案
  - 取值周期，间址周期，执行周期，中断周期(保存程序断点)
- 无条件转移指令不需要访存，只有取指和执行周期
- 数据通路：实现 CPU 内部的运算器和寄存器，以及寄存器之间的数据交换
  - CPU 内部总线方式：单总线结构，双总线结构，多总线结构
  - 专用数据通路方式：避免冲突，性能高，但硬件量较大
- 数据传送：寄存器之间的数据传送、主存和 CPU 之间的数据传送、执行算术或逻辑运算

- 控制器的结构和功能...

- 控制单元：输入：指令寄存器，标志，时钟，来自 CB 的控制信号；输出：CPU 内的控制信号，送至 CB 的信号

- 控制信号的来源：指令译码器产生的信息，时序系统产生的机器周期信号和节拍信号，来自执行单元的反馈标志，还接收来自系统总线的控制信号：中断请求、dma 请求

- 控制方式：控制不同操作序列时序信号的方法，分同步、异步、联合、人工

  - 同步控制方式：任何指令或微操作的执行都由事先确定且有统一基准时标的时序信号所控制
    - 采用完全统一节拍的机器周期（定长方式）
    - 采用不同节拍的机器周期（不定长方式）
    - 采用中央控制和局部控制相结合的方法：大部分指令安排在统一的较短的机器周期内完成，称为中央控制；少数操作复杂的指令中的某些操作采用局部控制方式来完成。局部控制节拍与中央控制节拍宽度相同，作为延续插入到中央控制的执行周期内，保证同步工作
  - 异步控制方式：时序由专门的应答线路控制，CPU 没有空闲状态但结构复杂
    - 一般用于主机与 I/O 设备间的传送控制，使二者可以按照各自的需要设置时序系统
  - 联合控制方式：大部分同步，小部分异步

- 组合逻辑控制，或硬布线逻辑控制：门电路组合实现，速度快，复杂，不灵活，可维护性差

  - 取值周期 间址周期 执行周期 中断周期

    (PC)→MAR AD(IR)→MAR（多次间址则为 MDR→MAR）

    1→R 1→R

    M(MAR)→MDR M(MAR)→MDR

    (MDR)→IR

    OP(IR)→CU

    (PC)+1→PC

  - 取指周期(1→FE)：PC→MAR→ 地址总线 → 主存，CU 发出读命令 → 控制总线 → 主存，主存 → 数据总线 →MDR→IR(存放指令)，CU 发出读命令 →PC 内容加 1

  - 间址周期(1→IND)：Ad(IR)(或 MDR)→MAR→ 地址总线 → 主存，CU 发出读命令 → 控制总线 → 主存，主存 → 数据总线 →MDR(存放有效地址)

  - 执行周期(1→EX)

  - 中断周期(1→INT)：CU 控制将 SP 减 1，SP→MAR→ 地址总线 → 主存，CU 发出写命令 → 控制总线 → 主存，PC→MDR→ 数据总线 → 主存(程序断点存入主存)，CU(中断服务程序的入口地址)→PC

  - 非访存指令

    - CLA 清 ACC 0→ACC
    - COM 取反 $\overline{ACC}$→ACC
    - SHR 算术右移 L(ACC)→R(ACC)，ACC0→ACC0
    - CSL 循环左移 R(ACC)→L(ACC)，ACC0→ACCn
    - STP 停机指令 0→G

  - 访存指令

    - ADD X 加法指令 STA X 存数指令 LDA X 取数指令

      Ad(IR)→MAR Ad(IR)→MAR Ad(IR)→MAR

      1→R 1→W 1→R

      M(MAR)→MDR ACC→MDR M(MAR)→MDR

      (ACC)+(MDR)→ACC MDR→M(MAR) MDR→ACC

  - 转移指令
    - JMP X 无条件转移 Ad(IR)→PC
    - BAN X 条件转移(负则转) $A_0·Ad(IR)+\overline{A_0}·(PC)→PC$
  - ![img](/img/in-post/cs_learning/2022-12-20-postgraduate-exam/transfer-instruction.png)

  - RET 子程序返回指令

- 微程序控制：存放在控制存储器 CS 中(ROM)，设计简单，添加容易，可维护性好，但速度慢

  - M 条指令对应 M+3 个微程序（加上取指，间址，中断）

  - 微操作是指令分解的最基本的、不可再分解的操作，微命令是控制部件向执行部件发出的各种控制命令。二者一一对应，微命令是微操作的控制信号，微操作是微命令的执行过程

  - 微操作是执行部件中最基本的操作，微命令是构成控制序列的最小单位

  - 微指令是若干微命令的集合，微地址是存放微指令的控制存储器的单元地址，微指令包含操作控制字段（微操作码字段）和顺序控制字段（微地址字段）

  - 微周期指从控制存储器中读取一条微指令并执行相应的微操作所需的时间

  - 控制存储器 CM 用于存放微程序，在 CPU 内部，用 ROM 实现

  - 程序是指令的有序集合，用于完成特定的功能，一条指令的功能由一段微程序来实现，微程序是微指令的有序集合

  - 组成：CM，CMAR，CMDR(或 μIR)，为地址形成部件，顺序逻辑（用来控制微指令序列）

  - 微指令的编码方式：又称控制方式，指如何对微指令的控制字段进行编码，以形成控制信号

    - **直接编码（直接控制）**方式：每一位控制一个微命令，简单直观、执行速度快、操作并行性好，缺点是微指令字长过长，造成控制存储器容量极大
    - **字段直接编码**方式：把**互斥性**微命令（同一微指令周期中不能同时出现的微命令）组合在**同一字段**中，把**相容性**微命令组合在**不同字段**中。每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关。可以缩短指令字长，但要通过译码电路再发出微命令，比较慢。每个小段中包含的信息位不能太多，一般还要**留出一个状态**(码字)表示本字段不发出任何现行指令
    - 字段间接编码方式：又称隐式编码，某些微命令需由另一个字段中的某些微命令来解释。进一步缩短指令字长，但削弱了微指令的并行控制能力，通常作为字段直接编码的辅助手段
    - 混合编码方式：直接编码和字段编码混合使用

  - 微指令序列地址的形成

    - 断定方式：后续微指令的地址可以由微指令的下地址字段直接给出
    - 后续微指令的地址还可根据机器指令的操作码形成。微地址形成部件实际是一个编码器，其输入为指令操作码。译码结果是对应该机器指令微程序的首地址，在微命令寄存器找到相应的微命令
    - 增量计数器法：(CMAR)+1→CMAR
    - 分支转移：`操作地址字段|转移方式|转移地址`转移方式必须考虑无条件转移的情况，个数+1
    - 由硬件产生微程序入口地址：机器指令操作码字段通过微地址形成部件产生微程序的入口地址，并将其送入 CMAR

  - | 微指令格式             | 水平型微指令                           | 垂直型微指令                           |
    | ---------------------- | -------------------------------------- | -------------------------------------- |
    | 并行性                 | 好                                     | 不好                                   |
    | 执行指令需要的微指令数 | 少                                     | 多                                     |
    | 和机器指令的相似度     | 差别很大                               | 相似                                   |
    | 最后陈述               | 用较短的微程序结构换取较长的微指令结构 | 用较长的微程序结构换取较段的微指令结构 |

  - 微操作的节拍和安排设计步骤，以取指操作为例。并行条件：不互相依赖，使用不同的线路

    - (PC→MAR), 1→R
    - **Ad(CMDR)→CMAR**
    - M(MAR)→MDR, (PC)+1→PC
    - **Ad(CMDR)→CMAR**
    - (MDR)→IR, OP(IR)→ 微地址形成部件
    - **OP(IR)→ 微地址形成部件 →CMAR**

  - 动态微程序设计：EPROM，根据用户要求改变为程序

  - 毫微程序设计：每条指令都通过微程序解释执行，通过控制线对硬件直接控制

- 指令流水线

  - 提高访存速度：采用高速存储芯片，高速缓冲寄存器和多体并行结构等
  - 提高主机与 I/O 交换信息的速度：DMA 方式，多总线结构
  - 提高处理器速度：采用高速的器件，改进系统的结构，开发系统的并行性（即指令流水线
  - 取指：根据 PC 从主存中取出指令送入 IR；分析：对操作码进行译码，按寻址方式和地址码内容形成有效地址 EA，并从有效地址中取出操作数；执行：根据操作码字段完成指令规定功能，将运算结构写到通用寄存器或者主存中
  - 四级流水：取指、指令译码、执行、回写
  - 六级流水：取指令 FI、指令译码 ID、计算操作数地址 CO、取操作数 FO、执行指令 EI、写操作数 WO
  - 处理器的度为 1 即常规标量单流水线处理器
  - 流水线需要装入时间和排空时间
  - 相关冲突：或称冒险
    - 资源相关/结构相关：争用同一功能部件。**插入暂停周期**或**增加资源**
    - 数据相关：写后读 RAW，读后写 WAR，写后写 WAW。**硬件阻塞 stall 或软件插入 NOP 指令**或使用**数据旁路**技术（设置相关专用通路
      - 在单发射、按序流动的普通流水线中，只可能出现 RAW 相关
    - 控制相关：由转移指令和其他改变 PC 值的指令引起。尽早判别转移是否发生，尽早生成转移目标地址**分支预测技术:静态和动态**；**预取**转移成功和不成功两个控制流方向上的目标指令；加快和提前形成**条件码**；提高转移方向的**猜准率**
  - 性能指标
    - 吞吐率：单位时间完成指令或输出结果的数量
    - 加速比：不使用流水线所用的时间与使用流水线所用的时间之比
    - 效率：设备利用率。$E=\frac{n个任务占时空图的有效面积}{n个任务所用的时间与k个流水段所围成的时空区总面积}$
  - m 段流水线稳定后，每个时钟周期流出一条指令，平均每个指令周期流出 m 条指令，与具备 m 个并行部件的 CPU 具备同等水平的吞吐能力
  - 适合流水的指令系统：指令长度尽量一致，指令格式尽量规整，保证除 Load/Store 指令以外的其他指令都不访问存储器，数据和指令在存储器中对齐存放
  - 超标量技术：可以**并发**执行多条独立指令，通过编译优化，挖掘指令并行性
  - 超级流水线：在一个时钟周期内再分段，一个时钟周期一个功能部件使用多次
  - 超长指令字：使用多个功能部件，挖掘并行性，并行指令组成超长指令字
  - 时空图纵坐标为空间即代表资源占用的指令阶段，也可写为处理器，指令执行过程图纵坐标为指令序列

- 流水线分类

  - 按级别：部件功能级，处理机级，处理机间
  - 按功能：单功能，多功能
  - 按连接方式：静态，动态
  - 按是否存在反馈信号：线性，非线性（适合线性递归运算）

- 中断系统：指令执行结束后有中断 → 中断周期：响应中断 → 关中断 → 找出中断源，保存(PC)→ 转移到中断服务子程序：保存(CPU)现场 → 设备服务 → 恢复 CPU 现场 → 开中断
  - 提出中断请求：中断请求标记触发器 INTR，多个 INTR 组成一个多位中断请求标记寄存器
  - 中断响应优先级：中断判优，硬件排队线路或中断查询程序
  - 中断处理优先级：中断屏蔽字
  - 寻找中断服务程序入口地址，即中断向量
    - 硬件向量法：利用中断向量地址形成部件产生中断向量地址，再由向量地址找到中断向量
      1. 当 CPU 响应中断时，将向量地址送到 PC，即可执行无条件转移指令
      2. 设置向量地址表，存放在存储单元内，存储单元的地址为向量地址，内容为中断向量
    - 软件查询法：软件安排转移指令直接指向此中断源的中断向量（由程序员或系统事先确定）
  - 条件：允许中断触发器 EINT=1，且有中断请求时，CPU 才可以响应中断
  - 时间：指令执行周期结束后查询是否有中断
  - 方式：进入中断周期后，由中断隐指令完成操作（硬件自动完成，不属于系统指令）
    - 保护程序断点：将 PC 和 PSW 的内容保存到存储器的特定单元或堆栈
    - 寻找中断向量
    - 关中断
  - 断点是中断返回时被中断程序继续执行处指令的地址和当时的 PSW 的内容，现场是被中断的原程序在断点处各个寄存器的值。断点的保护由中断隐指令完成，CPU 内寄存器内容的保护在中断服务程序中由用户或系统用机器指令编程实现，恢复现场也由中断服务程序完成，指将寄存器的内容恢复到中断处理前的状态
  - 单重中断：中断处理过程中的新中断请求等到执行完当前的服务程序后再响应
  - 多重中断：又称中断嵌套，考虑优先级
    - 条件：提前设置开中断指令，优先级别高的中断源有权中断优先级别低的中断源
    - 屏蔽技术：保证级别低的中断源不干扰比其级别高的中断源的中断处理过程。每个中断请求触发器都有一个屏蔽触发器，所有屏蔽触发器组合为屏蔽寄存器，内容称为屏蔽字（屏蔽码）
    - 保护现场 → 置屏蔽字 → 开中断 → 中断服务 → 关中断 → 恢复现场 → 恢复屏蔽字 → 开中断 → 中断返回

# 总线

- 总线是连接多个部件的信息传输线，是各部件共享的传输介质
  - 分时：同一时刻只允许一个部件向总线发送信息（但多个部件可以同时从总线上接收信息）
  - 共享：总线上可以挂载多个部件，各部件交换的信息可以通过总线分时共享
- 总线特性：机械(尺寸、形状)；电气(传输方向、有效电平范围)；功能(每根传输线的功能)；时间(信号和时序关系) **电功时机**
- 总线结构：
  - 数据传送总线：地址线、数据线、控制线，一般是32位或64位。为了减少布线，64位数据的低32位数据线常常和地址线采用分时复用方式
  - 仲裁总线：包括总线请求线和总线授权线
  - 中断和同步总线：用于处理带优先级的中断操作，包括中断请求线和终端认可线
  - 公用线：包括时钟信号线、电源线、地线、系统复位线以及加电或断电的时序信号线等
- 猝发传输：一个总线周期内传输存储地址连续的多个数据字，主设备只需给出首地址

## 总线的分类
- 按数据传送方式分为
  - 串行传送：脉冲传送
  - 并行传送：电位传送，并行又可按位数分为 8、16、32、64 位等。处于速度和效率考虑，系统总线上传送的信息必须采用并行传送方式
  - 分时传送：即总线的分时复用
- 按使用范围分为计算机总线、测控总线等
- 按连接部件不同分为
  - 片内总线：芯片内部，如 CPU 内部连接寄存器与寄存器之间、寄存器与 ALU 之间
  - 系统总线：连接五大部件之间的信息传输线
    - 数据总线：双向，与机器字长、存储字长有关
    - 地址总线：单向，用来指明 CPU 欲访问的存储单元或 I/O 设备的地址，由 CPU 给出
    - 控制总线：发出控制信号，分配总线使用权。单根单向，总体双向
  - 通信总线：用于计算机系统之间或计算机系统和其他系统之间的通信，又称外部总线，分同步和异步，串行和并行

## 总线的性能指标
- 总线时钟周期：即机器的时钟周期
- 总线时钟频率
- 总线传输周期：总线周期，指 CPU 通过总线对存储器或 I/O 端口进行一次访问（一次总线操作）所需的时间，包含若干总线时钟周期。申请，寻址，传输，结束
- **总线工作频率**：总线频率
- **总线宽度**：指**数据总线**的根数
- **总线带宽**：单位时间内总线上传输数据的字节数=总线宽度（字节） x 总线工作频率
- 总线复用：分时复用，如地址总线和数据总线共用一组线
- 信号线数：地址总线、数据总线和控制总线 3 种总线数的总和

## 总线的结构
- 单总线结构：结构简单，容易扩充。影响工作效率，不能解决 CPU、主存、I/O 设备之间传输速率不匹配的问题。多被小型计算机或微型计算机采用。**主存和 I/O 设备统一编址**
- 双总线结构：将**I/O 总线**与**主存总线**分开，需要增加通道等硬件设备
- 三总线结构1：增加一条**DMA 总线**用于高速外设和主存之间直接交换信息。任意时刻只能使用一种总线：主存总线和 DMA 总线不能同时对主存进行存取，I/O 总线只有在 CPU 执行 I/O 指令时才用到
- 三总线结构2：系统总线（Cache-主存），局部总线（又称CPU总线，CPU-Cache），扩展总线（系统总线-扩展总线接口-外设）
- 四总线结构：在三总线结构2上增加一条高速总线，用于区分高低速外设
- 桥是一种具有缓冲、转换、控制功能的逻辑电路，通过桥，CPU总线、系统总线和高速总线彼此相连，扩展总线通过扩展总线接口挂在高速总线上

## 总线仲裁，又称总线判优控制
- 主设备对总线有控制权，从设备只能响应从主设备发来的总线命令，对总线没有控制权
- 一根总线可以连接在若干设备上，有一个或多个主控设备，在一个总线传输周期内，一根总线只能有一个主控设备控制总线，选择一个从设备与之进行通信（可以有多个从方）
- 总线占用期：主方持续控制总线的时间
- 集中仲裁，集中控制优先权仲裁方式
  - 链式查询方式（总线控制部件依次检查询问） **3**
    - 离总线控制器越近的部件优先级越高
    - 优点：只需要**3 根**控制线（BS 总线忙，BR 总线请求，BG 总线同意）就能按一定的优先级实现总线控制，结构简单，易扩充
    - 缺点：对硬件电路的故障敏感；当优先级高的部件频繁请求使用总线时，低优先级部件饥饿
  - 计数器查询方式（计数器在总线控制部件里面） **log~2~n+2**
    - 相对于链式查询方式多了一**组**设备地址线，少了一**根**总线同意线，各设备仍共用一条请求线
    - 当总线控制器收到总线请求信号且判断总线不忙时，计数器开始计数，计数值通过一组地址线发向各个部件，当计数值与请求使用总线设备的地址一致时，该设备获得总线控制权，同时终止计数器的计数及查询工作
    - 计数方式分为从 0 开始（优先级固定）或从上次终点开始、即循环（优先级可以改变，初值可以由程序设置，所有设备的优先级相等）
    - 优点：优先级顺序可以改变，对电路的故障不如链式敏感
    - 缺点：增加了控制线数（-1，+log~2~n），控制也比链式查询复杂
  - 独立请求方式，每一个设备均有一对总线请求信号 BR~i~和总线同意信号 BG~i~ **2n+1**
    - 总线控制部件中有一个排队器，按一定的优先顺序决定批准某个部件的请求
    - 优点：响应时间很快（用线路换取），对优先级顺序的控制相当灵活
    - 缺点：控制线数多（n 个设备需要 2n+1 根控制线），总线控制更复杂
  - **确定总线使用权需要：链式 2 根，计数器 log~2~n+1，独立请求 2n 根**(控制线总数要再+1 表示总线忙)
- 分布仲裁：不需要中央仲裁器
  - 每个主模块有自己的**仲裁号**和仲裁器，通过发送仲裁号到共享的仲裁总线上进行竞争，优先级低的不响应且撤销仲裁号，获胜者的仲裁号保留在仲裁总线上

## 总线通信控制：主要解决通信双方如何获知传输开始和传输结束，以及通信双方如何协调和配合
- 同步通信，同步定时方式：统一的时钟信号协调发送和接收双方的传送定时关系
  - 不管是输入还是输出，地址信号一定是全程陪伴
  - 主模块发出地址信息 → 主模块发读命令 → 从模块提供数据 → 主模块撤销读命令，从模块撤销数据
  - 读/写命令一般是低电平有效，低电平时低阻抗，其抗干扰能力也较强
  - 优点：传送速度快，具有较高的传输速率
  - 缺点：必须按最慢的模块来设计公共时钟，损失总线效率；强制性同步，不知道外设是否真正响应，可靠性较低
  - 使用范围：总线长度较短，总线所接部件的存取时间比较接近
- 异步通信，异步定时方式：采用应答的方式（握手信号）控制，主从模块之间增加两条应答线
  - 根据请求和回答信号的撤销是否互锁，分为
    - 不互锁方式：没有互相制约关系，请求和回答信号都没有互锁
    - 半互锁方式：有简单的制约关系，请求信号有互锁，回答信号没有
    - 全互锁方式：有完全的制约关系，类似三次握手
  - 异步通信可用于并行传送或串行传送
- 半同步通信：既采用时钟信号，又采用握手信号。增加一条等待响应信号线
- 分离式通信：准备数据时不占用总线

## 总线标准
- **系统**总线标准：ISA，EISA(Extended，32 位 CPU)
- **局部**总线标准：
  - VESA：32 位标准局部总线，VL-BUS，针对高速传送活动图像的大量数据
  - PCI：最常用，高性能的 32 位或 64 位总线，**与 CPU 及时钟频率无关**，**支持即插即用**，采用**猝发传送**方式，可进行奇偶校验，扩展性好可通过**桥连接**实现多层 PCI 总线
    - PCI设备中不存在DMA概念，因为PCI总线支持无限的猝发传送
    - PCI总线采用同步时序协议和集中式仲裁策略，具有自动配置能力
  - PCI-Express：PCI-E，**串行**，采用类似 TCP/IP 的分层结构和数据帧逐层传递的模式，用于代替 PCI 和 AGP
  - AGP：视频接口标准，加速图形接口，连接主存和图形存储器
- **设备**总线标准：
  - RS-232C：是一种串行通信总线标准，用于串行二进制交换的数据终端设备 DTE 和数据通信设备 DCE 之间
  - USB：即插即用，热插拔，级联，**串行**总线
- PCMCIA：用于扩展功能的小型插槽，即插即用
- SCSI：小型计算机系统接口，用于计算机和智能设备之间的系统级接口的独立处理器标准
- IDE：ATE，集成设备电路，处理器和磁盘驱动器之间
- SATA：串行高级技术附件，串行硬件驱动器接口

# I/O 系统

- I/O 硬件
  - 在带接口的 I/O 系统中，包括接口模块和 I/O 设备
  - 在具有通道或 I/O 处理器的 I/O 系统中，包括通道（或处理器）、设备控制器和 I/O 设备
- I/O 软件：将用户编制的程序输入主机内，将运算结果输出给用户，实现 I/O 系统和主机工作的协调
  - 对采用接口模块方式，需要 I/O 指令；对于采用通道管理方式，不仅需要 I/O 指令，还需要通道指令
  - I/O 指令：`操作码|命令码|设备码`，I/O 指令通常在通用寄存器和 I/O 端口之间实现数据传送
  - 通道指令：又称通道控制字，存放在主存里面，由通道从主存中取出并执行。通道程序由通道指令组成，完成某种外设与主存之间传送信息的操作`首地址，尾地址，操作码，设备码`
    - 通道指令是通道的自身指令，不属于 CPU 指令系统，用来执行 I/O 操作。而 I/O 指令属于 CPU 指令系统的一部分，是 CPU 用来控制输入/输出操作的指令，由 CPU 译码后执行
    - 在具有通道结构的计算机中，I/O 指令不实现 I/O 数据传送，主要完成启动、停止 I/O 设备，查询通道和 I/O 设备的状态及控制通道所做的其他操作。即具有通道指令的计算机，一旦 CPU 执行了启动 I/O 设备的指令，就由通道来代替 CPU 对 I/O 设备的管理
- I/O 设备：输入设备（键盘，鼠标，扫描仪），输出设备（显示器，打印机），输入/输出兼用设备
  - 显示器：分辨率(像素个数)，灰度级(亮暗)，色深(颜色)，刷新频率，显示存储器 VRAM 容量=分辨率 x 灰度级位数，带宽=分辨率 x 灰度级位数 x 刷新频率(帧频)
    - 分类：阴极射线管显示器 CRT(纯平显示器)，液晶显示器 LCD，发光二极管显示器 LED...
  - 磁盘的平均存取时间=寻道时间+旋转延迟时间（磁盘转速倒数的一半）+传输时间
  - 磁盘地址：驱动器号，柱面(磁道)号，盘面号，扇区号
  - 硬盘工作过程：取控制字，执行控制字。寻址、读盘、写盘。串行
  - 磁盘阵列 RAID：提高传输率和吞吐量，提高安全性和容错能力
    - RAID0：无冗余和无校验，把连续多个数据块交替存放在不同磁盘的扇区中，几个磁盘交叉并行读写，扩大存储容量，提高存取速度，但没有容错能力
    - RAID1：镜像，提高可靠性，同时读写互为备份，容量减少一般
    - RAID2：采用纠错的海明码
    - RAID3：位交叉奇偶校验
    - RAID4：块交叉奇偶校验
    - RAID5：无独立校验的奇偶校验磁盘阵列
- I/O 接口
  - I/O 接口功能（I/O 控制器）：通信控制数据缓冲，地址译码和设备选择，格式转换，传送控制命令和状态信息
  - I/O 接口中用于存放命令、数据和状态信息的寄存器称为 I/O 端口，分别为数据端口、控制端口、状态端口
  - 结构：数据线（双向），设备选择线（单向），命令线（单向），状态线（单向）
    - 数据线 DB 双向，地址线 AD 和控制线 CB 都是由 CPU 向 I/O 设备的单向
  - 基本结构：中断请求触发器 INTR，屏蔽触发器 MASK，数据缓冲寄存器 DBR，设备选择电路，设备状态标记，控制逻辑电路，命令寄存器和命令译码器
  - 内部接口：与系统总线相连，实质上与内存、CPU 相连，只能并行传输
  - 外部接口：通过接口电缆与外设相连，可能串行传输，因此需要有串/并转换功能
  - 分类：
    - 按数据传送方式分类分为并行和串行接口
    - 按主机访问 I/O 设备的控制方式可以分为程序查询接口，中断接口和 DMA 接口
    - 按功能选择的灵活性可分为可编程接口和不可编程接口
  - 一个 I/O 接口可能有多个端口，每个端口有一个地址，因此一个 I/O 接口可能有多个地址
  - I/O 端口的编址分为统一编址(存储器映射方式)和独立编址(I/O 映射方式)。一个接口对应一个 I/O 设备
    - PC 中，显存数据量较大，一般直接映射到主存的指定空间，按主存方式读写。但对其它 I/O 设备，则采用独立方式编址，采用 I/O 指令。
- 程序查询方式，又称程序控制 I/O 方式
  - 完全由 CPU 主动控制，执行输入输出的服务程序（I/O 指令编写成的程序）
  - 缺点是要保持轮询查询，不会往回查（需要测试指令，转移指令，传送指令）
  - 保存寄存器内容 → 设置计数器 → 设置内存缓冲区首址 → 启动外设 → 是否准备就绪 → 传送一个数据 → 修改内存地址 → 修改计数器 →**查询是否传送完**→ 结束 I/O 传送
  - 数据成块传送，设置计数器，给出数据在主存缓冲区的首地址和数据的计数值
  - 准备就绪意味着输入缓冲满（CPU 可取）或输出缓冲空（CPU 可传）
  - 传送一个数据后，修改接口中的状态标志位、主存地址和计数器
  - CPU 与 I/O 串行工作，浪费时间；设备逻辑电路和控制器构成一个整体，增删设备困难
- 程序中断方式
  - 内中断，CPU 和内存内部产生的中断：地址非法，校验错，页面失效，存取访问控制错，算术操作溢出，数据格式非法，除数为零，非法指令，用户程序执行特权指令，用户态到内核态的切换(软中断)
  - 外中断，CPU 和内存以外的部件引起的中断：I/O 中断，外部信号中断(如键盘输入)，定时器引起的时钟中断(如时间片)
  - 中断请求 → 中断判优 → 中断响应 → 中断服务 → 中断返回
  - 硬件：中断请求触发器和中断屏蔽触发器，排队器，中断向量地址形成部件或称设备编码器（输入来自排队器的输出 INTP...，这串二进制代码即中断向量，位数与计算机可以处理中断源的个数有关，一个中断源对应一个向量地址）
  - 中断处理过程：CPU 启动 I/O 设备，B=1，D=0→ 接口启动设备开始准备工作 → 设备准备就绪 D=1 且本设备未被屏蔽 MASK=0，指令执行阶段结束时 CPU 发中断查询信号 → 设备 INTR=1，送至排队器进行中断判优 →CPU EINT=1 且设备被排队器选中，进入中断响应阶段，中断响应信号 INTA 将排队器输出送至编码器形成向量地址 → 向量地址送到 PC，存放的是一条无条件转移指令，开始执行中断服务程序 → 中断返回
  - 中断服务程序：保护现场和屏蔽字(存入寄存器或堆栈)(保存断点和关中断由中断隐指令完成)→ 开中断 → 执行中断服务程序 → 关中断 → 恢复现场和屏蔽字 → 开中断 → 中断返回(RETI，最后指令)
  - 接口模块：I/O 通过接口模块与主机相连，采用总线连接的方式。接口模块中设有数据通路和控制通路，可与 CPU 并行工作，大大提高工作效率；总线结构可以随时增加或删减设备
  - 结构：设备选择电路，数据缓冲寄存器，设备状态标志 B 工作触发器 D 完成触发器
  - 接口工作过程：CPU 通过 I/O 指令启动输入设备时，设备码字段通过地址线送入设备选择电路 → 接口设备码与地址线上的设备码吻合则 SEL 信号有效 →I/O 指令的启动命令经过与非门置 B1D0→B 触发器启动设备工作 → 输入设备将数据送至数据缓冲寄存器 → 设备发设备工作信号置 D1B0，表示准备就绪 →D 触发器发 Ready 信号通知 CPU→ 输入指令将数据缓冲寄存器的输入数据送至 CPU 的通用寄存器，再存入主存单元
- DMA（直接存储器存取）方式
  - I/O 设备和主存之间有一条直接数据通路（不是物理通路），可以直接交换信息。完全由硬件进行成组信息传送的控制方式，具有程序中断方式的优点：在数据准备阶段，CPU 与外设并行。降低了 CPU 在传送数据时的开销，但硬件开销较大，DMA 方式中中断的作用仅限于故障和中场传送结束时的处理。
  - 和 CPU 需要同时访问主存时 DMA 的传送方法：
    - 停止 CPU 访问主存：控制简单，适用于数据传输速率很高的设备成组传送。缺点：主存速度远高于设备，两个数据之间的准备间隔时间也总是大于一个存储周期，主存利用率低
    - 周期挪用：CPU 正在访存，则必须等待存储周期结束后 CPU 再让出总线控制权。若 I/O 和 CPU 同时请求访存，CPU 暂时放弃总线占有权，由 I/O 设备挪用一个或几个存储周期（每挪用一个主存周期都要申请总线控制权、建立总线控制权和归还总线控制权）
      - 除了后处理和申请挪用存取周期时，其他时候总线都供源程序占用(包括预处理和数据准备阶段)
      - 计算方法：每秒产生 DMA 的次数，每次 DMA 的时钟周期数，每秒 DMA 处理的总开销，DMA 占 CPU 的总时间等...
      - 单字传送，送完释放总线，整个数据块的传送过程中 CPU 可以访问主存
    - DMA 和 CPU 交替访问：适用于 CPU 的工作周期比主存存取周期长的情况。不需要总线控制权的申请、建立和归还过程，由 CPU 和 DMA 分时控制，CPU 既不停止主程序运行，也不进入等待状态
  - 外设(I/O 控制器)需要使用系统总线时优先级高于 CPU，若得不到及时响应，传输的数据可能会丢失，造成无法挽回的后果
  - DMA 接口，又称 DMA 控制器
    - 基本结构
      - AR：存放数据块在主存的首地址，具有计数功能
      - WC：字计数器，存放交换数据的字数
      - DAR：设备地址寄存器，用于存放设备号
      - BR：数据缓冲寄存器，存放主存和设备之间交换的数据字
      - 控制/状态逻辑：管理 DMA 的传送过程，由控制电路、时序电路和命令状态寄存器等组成
      - 中断逻辑(中断机构)：当字计数器溢出(全 0)时表示一批数据交换完毕，由溢出信号通过中断机构向 CPU 提出中断请求，请求 CPU 对 DMA 操作进行后处理
    - 功能：申请 DMA 数据传送；处理总线控制权的转交；管理系统总线，控制数据传送；确定数据传送的起始长度和数据长度，并修正数据传送过程中的数据地址和数据长度；给出 DMA 操作完成信号
  - DMA 传送过程
    - 预处理：指明是输入数据还是输出数据；向 DAR 送入设备号并启动设备；向 AR 送入交换数据的主存首地址；对 WC 赋予交换数据的个数
    - 数据传送：以数据块为单位。将数据读到 BR→ 设备向 DMA 接口发请求 DREQ→DMA 接口向 CPU 申请总线控制权 HRQ→CPU 发 HLDA 信号，允许将总线控制权交给 DMA 接口 → 将 AR 中的主存地址送地址总线，并命令存储器写 →DMA 控制逻辑告诉 I/O，CPU 已经安排了一个 DMA 周期，为下一个字的传送做准备 → 将 BR 的内容送数据总线 → 主存将数据总线上的信息写至地址总线制定的存储单元 → 修改主存地址和字计数值 → 判断数据块是否传送结束，结束则向 CPU 申请程序中断
      - 中断方式的中断包含数据的传输时间，DMA 的中断仅仅是后处理的时间
    - 后处理：校验数据是否正确，决定是否用 DMA 传送其他数据块，测试在传送过程中是否发生错误
- 程序中断方式和 DMA 比较
  - 数据传送：程序中断方式靠程序传送，DMA 方式靠**硬件**传送(DMA 完全由硬件控制数据交换的过程)
  - CPU 响应时间：中断方式在指令**执行周期**结束时响应，DMA 方式可在指令周期内任意**存储周期(机器周期)**结束时响应
  - 程序中断方式有处理异常事件的能力；DMA 没有，主要用于大批数据的传送
  - 程序中断方式需要中断现行程序，故需保护现场，DMA 不需要保护现场
  - DMA 的优先级比程序中断的优先级高
- 通道结构
  - 通道是用来负责管理 I/O 设备以及实现主存与 I/O 设备之间交换信息的部件，可以视为具有特殊功能的处理器。具有专用的通道指令，能独立地执行用通道指令所编写的输入/输出程序。依据 CPU 的**I/O 指令**进行启动、停止或改变工作状态，是从属于 CPU 的专用处理器，CPU 在交换信息时不直接参与管理，提高了效率
  - 程序和设备可以完全并行
  - ![IMG_8364](/img/in-post/cs_learning/2022-12-20-postgraduate-exam/IMG_8364.jpg)
- 具有 I/O 处理器的阶段
